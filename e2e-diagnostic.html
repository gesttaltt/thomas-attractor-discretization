<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E2E Diagnostic Scanner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            padding: 20px;
            margin: 0;
        }
        h2 { color: #00ffff; }
        .test-section {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .pass { color: #00ff00; }
        .fail { color: #ff0000; }
        .warn { color: #ffaa00; }
        .info { color: #00aaff; }
        .data { color: #ff00ff; }
        canvas {
            border: 1px solid #333;
            display: inline-block;
            margin: 10px;
        }
        #results {
            background: #000;
            padding: 10px;
            border: 1px solid #00ff00;
            max-height: 400px;
            overflow-y: auto;
            margin: 20px 0;
        }
        button {
            background: #003366;
            color: #00ffff;
            border: 1px solid #00ffff;
            padding: 10px 20px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #004488;
        }
    </style>
</head>
<body>
    <h1>üî¨ E2E Diagnostic Scanner</h1>
    <div id="results"></div>
    
    <div class="test-section">
        <h2>Test Canvases</h2>
        <canvas id="test3D" width="400" height="300"></canvas>
        <canvas id="test2D" width="400" height="300"></canvas>
    </div>
    
    <div class="test-section">
        <h2>Controls</h2>
        <button onclick="runFullDiagnostic()">üöÄ Run Full Diagnostic</button>
        <button onclick="testMath()">üßÆ Test Math Only</button>
        <button onclick="testRendering()">üé® Test Rendering Only</button>
        <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
    </div>

    <script type="module">
        const results = document.getElementById('results');
        let testApp = null;
        
        function log(msg, type = 'info') {
            const entry = document.createElement('div');
            entry.className = type;
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `[${timestamp}] <span class="${type}">${msg}</span>`;
            results.appendChild(entry);
            results.scrollTop = results.scrollHeight;
            console.log(`[${type}] ${msg}`);
        }
        
        window.clearResults = function() {
            results.innerHTML = '';
        }
        
        // Test 1: Dependencies
        async function testDependencies() {
            log('‚ïê‚ïê‚ïê DEPENDENCY CHECK ‚ïê‚ïê‚ïê', 'info');
            
            // THREE.js
            if (typeof THREE === 'undefined') {
                log('‚ùå THREE.js not loaded', 'fail');
                return false;
            }
            log('‚úÖ THREE.js loaded (version: ' + THREE.REVISION + ')', 'pass');
            
            // WebGL
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) {
                log('‚ùå WebGL not supported', 'fail');
                return false;
            }
            log('‚úÖ WebGL supported', 'pass');
            
            // Check modules
            try {
                const modules = [
                    './src/core/ThomasAttractor.js',
                    './src/core/ChaosAnalysis.js',
                    './src/visualization/Renderer3D.js',
                    './src/visualization/FloralProjection.js',
                    './src/ui/ControlPanel.js'
                ];
                
                for (const module of modules) {
                    await import(module);
                    log(`‚úÖ Module loaded: ${module}`, 'pass');
                }
            } catch (error) {
                log(`‚ùå Module load error: ${error.message}`, 'fail');
                return false;
            }
            
            return true;
        }
        
        // Test 2: Mathematical Engine
        async function testMathematicalEngine() {
            log('‚ïê‚ïê‚ïê MATHEMATICAL ENGINE TEST ‚ïê‚ïê‚ïê', 'info');
            
            try {
                const { ThomasAttractor } = await import('./src/core/ThomasAttractor.js');
                
                // Create attractor
                const attractor = new ThomasAttractor({ b: 0.19, dt: 0.005 });
                log('‚úÖ Attractor created', 'pass');
                
                // Test initial state
                const initial = attractor.getCurrentState();
                log(`üìä Initial state: [${initial[0].toFixed(4)}, ${initial[1].toFixed(4)}, ${initial[2].toFixed(4)}]`, 'data');
                
                // Generate trajectory
                const points = [];
                for (let i = 0; i < 1000; i++) {
                    const point = attractor.step(1);
                    points.push(...point);
                }
                log(`‚úÖ Generated ${points.length} points`, 'pass');
                
                // Check for NaN or Infinity
                let hasInvalid = false;
                for (const point of points) {
                    if (!isFinite(point[0]) || !isFinite(point[1]) || !isFinite(point[2])) {
                        hasInvalid = true;
                        break;
                    }
                }
                
                if (hasInvalid) {
                    log('‚ùå Invalid values detected (NaN or Infinity)', 'fail');
                    return false;
                }
                log('‚úÖ All values are finite', 'pass');
                
                // Check bounds
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                let minZ = Infinity, maxZ = -Infinity;
                
                for (const point of points) {
                    minX = Math.min(minX, point[0]);
                    maxX = Math.max(maxX, point[0]);
                    minY = Math.min(minY, point[1]);
                    maxY = Math.max(maxY, point[1]);
                    minZ = Math.min(minZ, point[2]);
                    maxZ = Math.max(maxZ, point[2]);
                }
                
                log(`üìä X range: [${minX.toFixed(2)}, ${maxX.toFixed(2)}]`, 'data');
                log(`üìä Y range: [${minY.toFixed(2)}, ${maxY.toFixed(2)}]`, 'data');
                log(`üìä Z range: [${minZ.toFixed(2)}, ${maxZ.toFixed(2)}]`, 'data');
                
                // Check if attractor is evolving
                const variance = (maxX - minX) + (maxY - minY) + (maxZ - minZ);
                if (variance < 0.1) {
                    log('‚ö†Ô∏è Attractor not evolving properly (too small variance)', 'warn');
                    return false;
                }
                log('‚úÖ Attractor dynamics OK', 'pass');
                
                return true;
                
            } catch (error) {
                log(`‚ùå Math engine error: ${error.message}`, 'fail');
                console.error(error);
                return false;
            }
        }
        
        // Test 3: 3D Rendering Pipeline
        async function test3DRendering() {
            log('‚ïê‚ïê‚ïê 3D RENDERING PIPELINE TEST ‚ïê‚ïê‚ïê', 'info');
            
            try {
                const { Renderer3D } = await import('./src/visualization/Renderer3D.js');
                const canvas = document.getElementById('test3D');
                
                // Create simple OrbitControls if needed
                if (!THREE.OrbitControls) {
                    THREE.OrbitControls = function(camera, domElement) {
                        this.update = function() {};
                    };
                }
                
                // Create renderer
                const renderer = new Renderer3D(canvas, {
                    maxParticles: 1000,
                    enableVolumetricEffects: false
                });
                log('‚úÖ 3D Renderer created', 'pass');
                
                // Check scene setup
                if (!renderer.scene) {
                    log('‚ùå Scene not created', 'fail');
                    return false;
                }
                log('‚úÖ Scene created', 'pass');
                
                if (!renderer.camera) {
                    log('‚ùå Camera not created', 'fail');
                    return false;
                }
                log('‚úÖ Camera created', 'pass');
                
                if (!renderer.renderer) {
                    log('‚ùå WebGL renderer not created', 'fail');
                    return false;
                }
                log('‚úÖ WebGL renderer created', 'pass');
                
                if (!renderer.particles) {
                    log('‚ùå Particle system not created', 'fail');
                    return false;
                }
                log('‚úÖ Particle system created', 'pass');
                
                // Add test points
                const testPoints = [];
                for (let i = 0; i < 100; i++) {
                    const angle = (i / 100) * Math.PI * 2;
                    testPoints.push([
                        Math.cos(angle) * 2,
                        Math.sin(angle) * 2,
                        i * 0.01
                    ]);
                }
                
                renderer.addPoints(testPoints);
                log(`‚úÖ Added ${testPoints.length} test points`, 'pass');
                
                // Test render
                renderer.render();
                log('‚úÖ Render executed', 'pass');
                
                // Check particle positions
                const positions = renderer.particles.geometry.attributes.position.array;
                let validPositions = 0;
                for (let i = 0; i < testPoints.length * 3; i += 3) {
                    if (positions[i] !== 0 || positions[i+1] !== 0 || positions[i+2] !== 0) {
                        validPositions++;
                    }
                }
                log(`üìä Valid particle positions: ${validPositions}/${testPoints.length}`, 'data');
                
                if (validPositions === 0) {
                    log('‚ùå No particles visible', 'fail');
                    return false;
                }
                
                return true;
                
            } catch (error) {
                log(`‚ùå 3D Rendering error: ${error.message}`, 'fail');
                console.error(error);
                return false;
            }
        }
        
        // Test 4: 2D Canvas Rendering
        async function test2DRendering() {
            log('‚ïê‚ïê‚ïê 2D CANVAS RENDERING TEST ‚ïê‚ïê‚ïê', 'info');
            
            try {
                const { FloralProjection } = await import('./src/visualization/FloralProjection.js');
                const canvas = document.getElementById('test2D');
                
                // Create projection
                const floral = new FloralProjection(canvas, {
                    projectionPlane: 'xy',
                    bufferSize: 1000
                });
                log('‚úÖ Floral projection created', 'pass');
                
                // Check context
                if (!floral.ctx) {
                    log('‚ùå 2D context not created', 'fail');
                    return false;
                }
                log('‚úÖ 2D context created', 'pass');
                
                // Add test points
                const testPoints = [];
                for (let i = 0; i < 100; i++) {
                    const angle = (i / 100) * Math.PI * 2;
                    testPoints.push([
                        Math.cos(angle),
                        Math.sin(angle),
                        0
                    ]);
                }
                
                floral.addPoints(testPoints);
                log(`‚úÖ Added ${testPoints.length} test points to 2D`, 'pass');
                
                // Test render
                floral.render();
                log('‚úÖ 2D render executed', 'pass');
                
                // Check if anything was drawn
                const imageData = floral.ctx.getImageData(0, 0, canvas.width, canvas.height);
                let nonBlackPixels = 0;
                for (let i = 0; i < imageData.data.length; i += 4) {
                    if (imageData.data[i] > 0 || imageData.data[i+1] > 0 || imageData.data[i+2] > 0) {
                        nonBlackPixels++;
                    }
                }
                
                log(`üìä Non-black pixels: ${nonBlackPixels}`, 'data');
                
                if (nonBlackPixels === 0) {
                    log('‚ö†Ô∏è No visible content in 2D canvas', 'warn');
                }
                
                return true;
                
            } catch (error) {
                log(`‚ùå 2D Rendering error: ${error.message}`, 'fail');
                console.error(error);
                return false;
            }
        }
        
        // Test 5: Full Integration
        async function testFullIntegration() {
            log('‚ïê‚ïê‚ïê FULL INTEGRATION TEST ‚ïê‚ïê‚ïê', 'info');
            
            try {
                const { ThomasAttractorApp } = await import('./src/app.js');
                
                // Create mini app
                const testCanvas3D = document.getElementById('test3D');
                const testCanvas2D = document.getElementById('test2D');
                
                if (!THREE.OrbitControls) {
                    THREE.OrbitControls = function(camera, domElement) {
                        this.update = function() {};
                        this.enableDamping = true;
                        this.autoRotate = false;
                    };
                }
                
                testApp = new ThomasAttractorApp({
                    mainCanvas: testCanvas3D,
                    floralCanvas: testCanvas2D,
                    controlsContainer: null, // No controls for test
                    maxParticles: 1000,
                    stepsPerFrame: 10,
                    enableVolumetricEffects: false
                });
                
                log('‚úÖ Full app created', 'pass');
                
                // Check components
                if (!testApp.attractor) {
                    log('‚ùå Attractor not initialized', 'fail');
                    return false;
                }
                log('‚úÖ Attractor initialized', 'pass');
                
                if (!testApp.renderer3D) {
                    log('‚ùå 3D renderer not initialized', 'fail');
                    return false;
                }
                log('‚úÖ 3D renderer initialized', 'pass');
                
                if (!testApp.floralProjection) {
                    log('‚ùå 2D projection not initialized', 'fail');
                    return false;
                }
                log('‚úÖ 2D projection initialized', 'pass');
                
                // Check if animation is running
                const isRunning = testApp.isRunning;
                log(`üìä Animation running: ${isRunning}`, 'data');
                
                if (!isRunning) {
                    log('‚ö†Ô∏è Animation not started automatically', 'warn');
                    testApp.startSimulation();
                }
                
                // Let it run for a bit
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Check stats
                const stats = testApp.getStats();
                log(`üìä Frame count: ${stats.frameCount}`, 'data');
                log(`üìä Particle count: ${stats.particleCount}`, 'data');
                log(`üìä FPS: ${stats.performance.fps.toFixed(1)}`, 'data');
                
                if (stats.frameCount === 0) {
                    log('‚ùå No frames rendered', 'fail');
                    return false;
                }
                
                log('‚úÖ Full integration test passed', 'pass');
                return true;
                
            } catch (error) {
                log(`‚ùå Integration error: ${error.message}`, 'fail');
                console.error(error);
                return false;
            }
        }
        
        // Main diagnostic function
        window.runFullDiagnostic = async function() {
            clearResults();
            log('üöÄ STARTING E2E DIAGNOSTIC SCAN', 'info');
            log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            
            const tests = [
                { name: 'Dependencies', fn: testDependencies },
                { name: 'Mathematical Engine', fn: testMathematicalEngine },
                { name: '3D Rendering', fn: test3DRendering },
                { name: '2D Rendering', fn: test2DRendering },
                { name: 'Full Integration', fn: testFullIntegration }
            ];
            
            const results = [];
            
            for (const test of tests) {
                log(`\nüî¨ Running: ${test.name}`, 'info');
                const result = await test.fn();
                results.push({ name: test.name, passed: result });
                
                if (!result) {
                    log(`‚ö†Ô∏è ${test.name} failed, continuing...`, 'warn');
                }
            }
            
            // Summary
            log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            log('üìä DIAGNOSTIC SUMMARY', 'info');
            
            const passed = results.filter(r => r.passed).length;
            const failed = results.filter(r => !r.passed).length;
            
            results.forEach(r => {
                log(`${r.passed ? '‚úÖ' : '‚ùå'} ${r.name}`, r.passed ? 'pass' : 'fail');
            });
            
            log(`\nüìà Results: ${passed}/${results.length} tests passed`, passed === results.length ? 'pass' : 'warn');
            
            if (failed > 0) {
                log('üîß RECOMMENDED FIXES:', 'warn');
                
                if (!results[0].passed) {
                    log('‚Ä¢ Check that all JavaScript files are loading correctly', 'info');
                    log('‚Ä¢ Verify THREE.js CDN is accessible', 'info');
                }
                
                if (!results[1].passed) {
                    log('‚Ä¢ Mathematical computation may have numerical issues', 'info');
                    log('‚Ä¢ Check attractor parameters (b, dt)', 'info');
                }
                
                if (!results[2].passed) {
                    log('‚Ä¢ WebGL context may not be initializing', 'info');
                    log('‚Ä¢ Check browser WebGL support', 'info');
                }
                
                if (!results[3].passed) {
                    log('‚Ä¢ 2D canvas context issues', 'info');
                    log('‚Ä¢ Check canvas element accessibility', 'info');
                }
                
                if (!results[4].passed) {
                    log('‚Ä¢ Component initialization order may be wrong', 'info');
                    log('‚Ä¢ Check async/await flow in app.js', 'info');
                }
            } else {
                log('üéâ All systems operational!', 'pass');
            }
        }
        
        window.testMath = testMathematicalEngine;
        window.testRendering = async function() {
            clearResults();
            await test3DRendering();
            await test2DRendering();
        }
        
        // Auto-run on load
        window.addEventListener('load', () => {
            log('üî¨ E2E Diagnostic Scanner Ready', 'info');
            log('Click "Run Full Diagnostic" to begin', 'info');
        });
    </script>
</body>
</html>